<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Pulse V4: Waves & Upgrades</title>
    <style>
        body {
            margin: 0; padding: 0;
            background-color: #050510;
            overflow: hidden;
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            color: white;
            user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between;
            padding: 15px; box-sizing: border-box;
        }
        
        /* Top HUD */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .score-box { font-size: 24px; font-weight: bold; text-shadow: 0 0 10px cyan; }
        .wave-box { font-size: 30px; color: yellow; font-weight: bold; text-shadow: 0 0 10px orange; }
        
        /* HP Bar */
        .hp-container {
            width: 200px; height: 20px;
            background: #333; border: 2px solid #555;
            margin-top: 5px; position: relative;
        }
        #hp-bar {
            width: 100%; height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff5500);
            transition: width 0.2s;
        }
        #hp-text {
            position: absolute; top: 0; left: 0; width: 100%;
            text-align: center; font-size: 14px; line-height: 20px;
            text-shadow: 1px 1px 2px black;
        }

        /* Screens */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; pointer-events: auto; z-index: 100;
        }
        #game-over-screen { display: none; }
        
        h1 { margin: 0 0 20px 0; color: cyan; text-shadow: 0 0 20px cyan; text-align: center; font-size: 40px;}
        p { margin: 5px 0; color: #ccc; }
        
        .btn {
            padding: 15px 40px; margin-top: 20px;
            border: 2px solid cyan; color: cyan; background: transparent;
            font-size: 20px; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 15px cyan; transition: 0.2s;
        }
        .btn:active { background: cyan; color: black; transform: scale(0.95); }

        /* Wave Notification */
        #wave-notify {
            position: absolute; top: 30%; width: 100%;
            text-align: center; color: yellow; font-size: 60px; font-weight: bold;
            text-shadow: 0 0 30px red; display: none;
            animation: zoomFade 2s forwards;
        }
        @keyframes zoomFade { 
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Mobile Controls */
        .control-zone {
            position: absolute; bottom: 40px;
            width: 120px; height: 120px;
            border-radius: 50%; pointer-events: auto; display: none;
            border: 2px solid rgba(255,255,255,0.1);
        }
        #stick-zone { left: 20px; }
        #fire-zone { right: 20px; background: rgba(255,0,0,0.1); display: none; }
        #stick-nub {
            width: 50px; height: 50px; background: rgba(0,255,255,0.5);
            border-radius: 50%; position: relative; top: 35px; left: 35px;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div>
                <div class="score-box" id="score-text">SCORE: 0</div>
                <div class="hp-container">
                    <div id="hp-bar"></div>
                    <div id="hp-text">100/100</div>
                </div>
            </div>
            <div class="wave-box" id="wave-text">WAVE 1</div>
        </div>
        
        <div id="wave-notify">WAVE 1 START!</div>

        <div id="stick-zone" class="control-zone"><div id="stick-nub"></div></div>
        <div id="fire-zone" class="control-zone"></div>
    </div>

    <div id="start-screen">
        <h1>NEON PULSE V4</h1>
        <p>Wave 5: Mini Boss | Wave 10: MEGA BOSS</p>
        <p>Collect Items to Upgrade Weapons!</p>
        <button class="btn" onclick="startGame()">DEPLOY SHIP</button>
    </div>

    <div id="game-over-screen">
        <h1 style="color: red; text-shadow: 0 0 20px red;">MISSION FAILED</h1>
        <p id="final-score">Score: 0</p>
        <p id="final-wave">Reached Wave: 1</p>
        <button class="btn" onclick="startGame()">RETRY</button>
    </div>

<script>
// --- ENGINE SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let width, height;

// UI Elements
const uiScore = document.getElementById('score-text');
const uiWave = document.getElementById('wave-text');
const uiHpBar = document.getElementById('hp-bar');
const uiHpText = document.getElementById('hp-text');
const waveNotify = document.getElementById('wave-notify');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');

// Game State
let isPlaying = false;
let score = 0;
let wave = 1;
let frameCount = 0;
let enemiesToSpawn = 0;
let spawnTimer = 0;
let waveState = 'waiting'; // waiting, spawning, fighting, boss

// Audio Context
const AudioContext = window.AudioContext || window.webkitAudioContext;
let actx;

// --- AUDIO SYSTEM ---
function playSound(type) {
    if (!actx) return;
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.connect(gain);
    gain.connect(actx.destination);
    const now = actx.currentTime;

    if (type === 'shoot') {
        osc.frequency.setValueAtTime(300 + (player.weaponLevel * 50), now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'hit') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'powerup') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now); osc.stop(now + 0.3);
    } else if (type === 'wave') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(400, now + 1);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 1);
        osc.start(now); osc.stop(now + 1);
    }
}

// --- GAME OBJECTS ---
const player = {
    x: 0, y: 0, r: 15, angle: 0,
    hp: 100, maxHp: 100,
    dead: false,
    weaponLevel: 1, // 1: Single, 2: Double, 3: Triple, 4: Spread
    fireRate: 15, // Frames per shot (Lower is faster)
    lastShot: 0,
    invulnTimer: 0 // Thời gian bất tử sau khi trúng đòn
};

let bullets = [];
let enemyBullets = [];
let enemies = [];
let particles = [];
let drops = []; // Items on ground
let floatingTexts = []; // Damage numbers / Text

// --- INITIALIZATION ---
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    if(!isPlaying) { player.x = width/2; player.y = height/2; }
}
window.addEventListener('resize', resize);
resize();

if (isMobile) {
    document.getElementById('stick-zone').style.display = 'block';
    document.getElementById('fire-zone').style.display = 'block';
}

function startGame() {
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    
    // Reset Stats
    isPlaying = true;
    score = 0;
    wave = 1;
    player.hp = 100; player.maxHp = 100; player.dead = false;
    player.weaponLevel = 1; player.fireRate = 20; player.invulnTimer = 0;
    player.x = width/2; player.y = height/2;
    
    // Clear Entities
    bullets = []; enemies = []; enemyBullets = []; particles = []; drops = []; floatingTexts = [];
    
    updateUI();
    actx = new AudioContext();
    actx.resume();
    
    startWave();
    requestAnimationFrame(loop);
}

// --- WAVE SYSTEM ---
function startWave() {
    waveState = 'spawning';
    uiWave.innerText = "WAVE " + wave;
    showNotification("WAVE " + wave);
    playSound('wave');

    // Boss Check
    if (wave % 10 === 0) {
        enemiesToSpawn = 1; // Boss only
        spawnBoss('mega');
    } else if (wave % 5 === 0) {
        enemiesToSpawn = 1; // Mini boss
        spawnBoss('mini');
    } else {
        // Normal Wave: Increase count
        enemiesToSpawn = 4 + (wave * 2); 
    }
}

function showNotification(text) {
    waveNotify.innerText = text;
    waveNotify.style.display = 'none';
    void waveNotify.offsetWidth; // Trigger reflow
    waveNotify.style.display = 'block';
}

// --- SPAWNING LOGIC ---
function spawnBoss(type) {
    waveState = 'boss';
    let boss;
    if (type === 'mega') {
        boss = {
            x: width/2, y: -150, r: 80, hp: 1000 + (wave * 100), maxHp: 1000 + (wave * 100),
            type: 'boss_mega', color: '#ff0000', speed: 1.5, angle: 0, reload: 0
        };
        showNotification("⚠️ MEGA BOSS ⚠️");
    } else {
        boss = {
            x: width/2, y: -100, r: 40, hp: 400 + (wave * 50), maxHp: 400 + (wave * 50),
            type: 'boss_mini', color: '#ffaa00', speed: 3, angle: 0, reload: 0
        };
        showNotification("⚠️ ELITE ENEMY ⚠️");
    }
    enemies.push(boss);
    enemiesToSpawn = 0;
}

function spawnNormalEnemy() {
    if (enemiesToSpawn <= 0) {
        waveState = 'fighting';
        return;
    }

    // Spawn Rates based on Wave
    let typeRoll = Math.random();
    let type = 'chaser', hp = 2 + Math.floor(wave/3), color = '#ff0055', spd = 2 + Math.random();
    let r = 15;

    // Wave 3+: Shooter appears
    if (wave >= 3 && typeRoll > 0.7) { 
        type = 'shooter'; color = '#00ff00'; spd = 1.5; hp = 3 + Math.floor(wave/4);
    }
    // Wave 6+: Tank appears
    if (wave >= 6 && typeRoll > 0.9) { 
        type = 'tank'; r = 25; hp = 10 + wave; color = '#5555ff'; spd = 1; 
    }

    // Position
    let ex, ey;
    if(Math.random() < 0.5) {
        ex = Math.random() < 0.5 ? -50 : width+50; ey = Math.random()*height;
    } else {
        ex = Math.random()*width; ey = Math.random() < 0.5 ? -50 : height+50;
    }

    enemies.push({ x: ex, y: ey, r, hp, maxHp: hp, type, color, speed: spd, angle: 0, reload: 0 });
    enemiesToSpawn--;
}

function spawnDrop(x, y) {
    if (Math.random() > 0.3) return; // 30% chance drop

    let type = 'score';
    let color = 'white';
    let roll = Math.random();

    if (roll < 0.1) { type = 'heal'; color = '#ff0000'; } // 10% Heal
    else if (roll < 0.2) { type = 'upgrade'; color = '#00ffff'; } // 10% Upgrade
    else if (roll < 0.3) { type = 'speed'; color = '#ffff00'; } // 10% Fire Rate
    
    drops.push({ x, y, type, color, r: 10, vy: -2, life: 600 });
}

// --- INPUT ---
const keys = {};
const mouse = { x: 0, y: 0 };
const joystick = { active: false, dx: 0, dy: 0, startX: 0, startY: 0 };

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('mousedown', () => { if(isPlaying && !isMobile) shoot(); });

// Mobile Joy
const stickZone = document.getElementById('stick-zone');
const stickNub = document.getElementById('stick-nub');
stickZone.addEventListener('touchstart', e => {
    e.preventDefault(); joystick.active = true;
    joystick.startX = e.touches[0].clientX; joystick.startY = e.touches[0].clientY;
}, {passive:false});
stickZone.addEventListener('touchmove', e => {
    e.preventDefault(); if(!joystick.active) return;
    let dx = e.touches[0].clientX - joystick.startX;
    let dy = e.touches[0].clientY - joystick.startY;
    const dist = Math.min(Math.hypot(dx, dy), 35);
    const angle = Math.atan2(dy, dx);
    joystick.dx = Math.cos(angle); joystick.dy = Math.sin(angle);
    stickNub.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
}, {passive:false});
stickZone.addEventListener('touchend', () => {
    joystick.active = false; joystick.dx = 0; joystick.dy = 0;
    stickNub.style.transform = `translate(0,0)`;
});
document.getElementById('fire-zone').addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); });

// --- GAME LOGIC ---
function takeDamage(amount) {
    if (player.invulnTimer > 0 || player.dead) return;
    
    player.hp -= amount;
    player.invulnTimer = 60; // 1s invuln
    addFloatingText(player.x, player.y - 20, "-" + amount, "red");
    
    // Screen shake
    ctx.translate(Math.random()*10-5, Math.random()*10-5);
    
    if (player.hp <= 0) {
        player.hp = 0;
        gameOver();
    }
    updateUI();
}

function heal(amount) {
    player.hp = Math.min(player.hp + amount, player.maxHp);
    addFloatingText(player.x, player.y - 20, "+" + amount, "#0f0");
    updateUI();
}

function upgradeWeapon() {
    if (player.weaponLevel < 5) {
        player.weaponLevel++;
        addFloatingText(player.x, player.y - 40, "WEAPON UP!", "cyan");
    } else {
        score += 50; // Max level gives score
        addFloatingText(player.x, player.y - 40, "+50 PTS", "cyan");
    }
    updateUI();
}

function shoot() {
    if(player.dead) return;
    if(frameCount - player.lastShot < player.fireRate) return;
    
    player.lastShot = frameCount;
    playSound('shoot');
    
    const angle = (isMobile && (joystick.dx||joystick.dy)) ? Math.atan2(joystick.dy, joystick.dx) : Math.atan2(mouse.y - player.y, mouse.x - player.x);
    
    // Weapon Patterns
    const speed = 15;
    if (player.weaponLevel === 1) {
        bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed });
    } else if (player.weaponLevel === 2) {
        bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle-0.1)*speed, vy: Math.sin(angle-0.1)*speed });
        bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle+0.1)*speed, vy: Math.sin(angle+0.1)*speed });
    } else if (player.weaponLevel >= 3) {
        for(let i=-1; i<=1; i++) {
            bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle + i*0.15)*speed, vy: Math.sin(angle + i*0.15)*speed });
        }
    } 
    if (player.weaponLevel >= 4) { // Rear shot
         bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle + Math.PI)*speed, vy: Math.sin(angle + Math.PI)*speed });
    }
}

function update() {
    if(player.dead) return;
    frameCount++;
    if(player.invulnTimer > 0) player.invulnTimer--;

    // Auto Fire (PC Hold Mouse)
    if (!isMobile && mouse.down) shoot(); // Cần thêm event mousedown/up cho mouse object
    
    // Wave Management
    if (waveState === 'spawning') {
        spawnTimer++;
        if (spawnTimer > 30) { spawnNormalEnemy(); spawnTimer = 0; }
    } else if (waveState === 'fighting' || waveState === 'boss') {
        if (enemies.length === 0 && enemiesToSpawn === 0) {
            wave++;
            setTimeout(startWave, 2000); // Wait 2s then next wave
            waveState = 'waiting';
        }
    }

    // Player Move
    const spd = 5;
    if(isMobile) { player.x += joystick.dx * spd; player.y += joystick.dy * spd; }
    else {
        if(keys['KeyW']) player.y -= spd; if(keys['KeyS']) player.y += spd;
        if(keys['KeyA']) player.x -= spd; if(keys['KeyD']) player.x += spd;
        // Auto shoot on PC if Space held
        if(keys['Space']) shoot();
    }
    player.x = Math.max(15, Math.min(width-15, player.x));
    player.y = Math.max(15, Math.min(height-15, player.y));

    // Drops Logic
    for(let i=drops.length-1; i>=0; i--) {
        let d = drops[i];
        d.y += Math.sin(frameCount/20) * 0.5; // Float effect
        d.life--;
        
        // Pick up
        if(Math.hypot(player.x - d.x, player.y - d.y) < player.r + d.r) {
            playSound('powerup');
            if (d.type === 'heal') heal(30);
            else if (d.type === 'upgrade') upgradeWeapon();
            else if (d.type === 'speed') { player.fireRate = Math.max(5, player.fireRate - 2); addFloatingText(player.x, player.y-40, "SPEED UP", "yellow"); }
            else { score += 100; addFloatingText(player.x, player.y-20, "+100", "white"); }
            
            drops.splice(i, 1);
            continue;
        }
        if(d.life <= 0) drops.splice(i, 1);
    }

    // Bullets
    bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
    bullets = bullets.filter(b => b.x > 0 && b.x < width && b.y > 0 && b.y < height);

    enemyBullets.forEach(b => { 
        b.x += b.vx; b.y += b.vy; 
        if(Math.hypot(b.x-player.x, b.y-player.y) < player.r) {
            takeDamage(10);
            // Bullet destroyed
            b.active = false; 
        }
    });
    enemyBullets = enemyBullets.filter(b => b.x > 0 && b.x < width && b.y > 0 && b.y < height && b.active !== false);

    // Enemies
    for(let i=enemies.length-1; i>=0; i--) {
        let e = enemies[i];
        
        // Movement
        if (e.type.includes('boss')) {
            e.y = Math.min(100, e.y + e.speed);
            e.reload++;
            
            // Mega Boss Skill: Spiral
            if (e.type === 'boss_mega') {
                 e.angle += 0.02;
                 if (e.reload > 5) { // Machine gun spiral
                     enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(e.angle)*5, vy: Math.sin(e.angle)*5 });
                     enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(e.angle+Math.PI)*5, vy: Math.sin(e.angle+Math.PI)*5 });
                     e.reload = 0;
                 }
            } else { // Mini Boss: Aimed shots
                 if (e.reload > 60) {
                     const ang = Math.atan2(player.y - e.y, player.x - e.x);
                     enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(ang)*7, vy: Math.sin(ang)*7 });
                     enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(ang-0.3)*6, vy: Math.sin(ang-0.3)*6 });
                     enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(ang+0.3)*6, vy: Math.sin(ang+0.3)*6 });
                     e.reload = 0;
                 }
            }
        } else {
            // Normal Logic
            const angle = Math.atan2(player.y - e.y, player.x - e.x);
            const dist = Math.hypot(player.x - e.x, player.y - e.y);
            
            if (e.type === 'shooter' && dist < 300) {
                // Keep distance
            } else {
                e.x += Math.cos(angle)*e.speed; e.y += Math.sin(angle)*e.speed;
            }
            
            if(e.type === 'shooter') {
                e.reload++;
                if(e.reload > 120) { 
                    enemyBullets.push({ x: e.x, y: e.y, vx: Math.cos(angle)*5, vy: Math.sin(angle)*5 }); 
                    e.reload = 0; 
                }
            }
        }

        // Collision: Bullet vs Enemy
        for(let j=bullets.length-1; j>=0; j--) {
            let b = bullets[j];
            let hitR = e.r + 5;
            if(Math.hypot(b.x - e.x, b.y - e.y) < hitR) {
                bullets.splice(j, 1);
                e.hp--;
                // Visual hit
                e.x += (Math.random()-0.5)*4; 
                createParticles(b.x, b.y, 'white', 2);
                
                if(e.hp <= 0) {
                    killEnemy(e, i);
                }
                break;
            }
        }

        // Collision: Player vs Enemy
        if(enemies[i] && Math.hypot(player.x - enemies[i].x, player.y - enemies[i].y) < player.r + enemies[i].r) {
             takeDamage(20);
        }
    }

    // Particles & Text
    particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.05; });
    particles = particles.filter(p => p.life > 0);
    
    floatingTexts.forEach(t => { t.y -= 1; t.life--; });
    floatingTexts = floatingTexts.filter(t => t.life > 0);
}

function killEnemy(e, index) {
    createParticles(e.x, e.y, e.color, 10);
    spawnDrop(e.x, e.y);
    playSound('hit');
    
    let pts = 10;
    if (e.type.includes('boss')) pts = 500;
    
    score += pts;
    updateUI();
    enemies.splice(index, 1);
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) particles.push({ x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1.0, color });
}

function addFloatingText(x, y, text, color) {
    floatingTexts.push({ x, y, text, color, life: 60 });
}

function gameOver() {
    player.dead = true;
    createParticles(player.x, player.y, 'cyan', 50);
    isPlaying = false;
    document.getElementById('final-score').innerText = "Final Score: " + score;
    document.getElementById('final-wave').innerText = "Reached Wave: " + wave;
    gameOverScreen.style.display = 'flex';
}

function updateUI() {
    uiScore.innerText = "SCORE: " + score;
    uiHpBar.style.width = (player.hp / player.maxHp * 100) + "%";
    uiHpText.innerText = Math.floor(player.hp) + "/" + player.maxHp;
}

// --- DRAWING ---
function draw() {
    ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, width, height);
    
    // Grid
    ctx.strokeStyle = '#001133'; ctx.lineWidth = 1; ctx.beginPath();
    for(let x=0; x<width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
    for(let y=0; y<height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
    ctx.stroke();

    // Drops
    drops.forEach(d => {
        ctx.fillStyle = d.color; 
        ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'black'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
        let symbol = '?';
        if(d.type==='heal') symbol = '❤';
        if(d.type==='upgrade') symbol = '⚡';
        if(d.type==='speed') symbol = '⏩';
        ctx.fillText(symbol, d.x, d.y+4);
    });

    if(player.dead) return;

    // Player
    if (player.invulnTimer % 4 < 2) { // Blink effect
        ctx.save(); ctx.translate(player.x, player.y);
        const rot = (isMobile && (joystick.dx||joystick.dy)) ? Math.atan2(joystick.dy, joystick.dx) : Math.atan2(mouse.y-player.y, mouse.x-player.x);
        ctx.rotate(rot);
        
        // Ship Level Visuals
        ctx.fillStyle = '#003333'; ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
        ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
        
        ctx.beginPath(); 
        ctx.moveTo(20,0); ctx.lineTo(-15,15); ctx.lineTo(-5,0); ctx.lineTo(-15,-15); 
        ctx.closePath(); ctx.fill(); ctx.stroke();
        
        // Wing upgrades
        if(player.weaponLevel >= 3) {
            ctx.beginPath(); ctx.moveTo(-5,15); ctx.lineTo(-15, 25); ctx.lineTo(0, 15); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-5,-15); ctx.lineTo(-15, -25); ctx.lineTo(0, -15); ctx.stroke();
        }
        ctx.restore();
    }

    // Entities
    ctx.fillStyle = '#ffff00'; ctx.shadowColor = '#ffff00';
    bullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });
    
    ctx.fillStyle = '#fff'; ctx.shadowColor = 'red';
    enemyBullets.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });

    enemies.forEach(e => {
        ctx.save(); ctx.translate(e.x, e.y);
        ctx.strokeStyle = e.color; ctx.lineWidth = 2; ctx.shadowColor = e.color;
        
        if(e.type.includes('boss')) {
            ctx.rotate(e.angle);
            ctx.beginPath(); ctx.arc(0,0, e.r, 0, Math.PI*2); ctx.stroke(); // Body
            ctx.beginPath(); ctx.moveTo(0, -e.r); ctx.lineTo(0, e.r); ctx.moveTo(-e.r, 0); ctx.lineTo(e.r, 0); ctx.stroke(); // Cross
            
            // Health Bar for Boss
            ctx.restore();
            ctx.fillStyle = 'red'; ctx.fillRect(e.x - 40, e.y - e.r - 20, 80, 5);
            ctx.fillStyle = '#0f0'; ctx.fillRect(e.x - 40, e.y - e.r - 20, 80 * (e.hp/e.maxHp), 5);
        } else {
            // Normal Shapes
            if(e.type === 'shooter') { 
                ctx.beginPath(); for(let k=0; k<6; k++) ctx.lineTo(20*Math.cos(k*Math.PI/3), 20*Math.sin(k*Math.PI/3)); ctx.closePath(); ctx.stroke();
            } else if(e.type === 'tank') {
                ctx.strokeRect(-e.r, -e.r, e.r*2, e.r*2);
            } else { 
                ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(-10,10); ctx.lineTo(-10,-10); ctx.closePath(); ctx.stroke(); 
            }
            ctx.restore();
        }
    });

    particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha = 1; });
    
    // Floating Text
    ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
    floatingTexts.forEach(t => {
        ctx.fillStyle = t.color;
        ctx.fillText(t.text, t.x, t.y);
    });
}

function loop() { if(isPlaying) { update(); draw(); requestAnimationFrame(loop); } }
</script>
</body>
</html>
